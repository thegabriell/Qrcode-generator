"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isNullishEnumVal = exports.isNullableEnumVal = exports.isOptionalEnumVal = exports.isEnumVal = exports.isNullishEnum = exports.isNullableEnum = exports.isOptionalEnum = exports.isEnum = exports.isNullishKeyOfArray = exports.isNullableKeyOfArray = exports.isOptionalKeyOfArray = exports.isKeyOfArray = exports.isNullishKeyOf = exports.isNullableKeyOf = exports.isOptionalKeyOf = exports.isKeyOf = exports.isNullishInRangeArray = exports.isNullableInRangeArray = exports.isOptionalInRangeArray = exports.isInRangeArray = exports.isNullishInRange = exports.isNullableInRange = exports.isOptionalInRange = exports.isInRange = exports.isNullishInArray = exports.isNullableInArray = exports.isOptionalInArray = exports.isInArray = void 0;
exports._isInArray = _isInArray;
const basic_1 = require("./basic");
const common_1 = require("./common");
const isInArray = (arg) => _isInArray(arg, false, false);
exports.isInArray = isInArray;
const isOptionalInArray = (arg) => _isInArray(arg, true, false);
exports.isOptionalInArray = isOptionalInArray;
const isNullableInArray = (arg) => _isInArray(arg, false, true);
exports.isNullableInArray = isNullableInArray;
const isNullishInArray = (arg) => _isInArray(arg, true, true);
exports.isNullishInArray = isNullishInArray;
function _isInArray(arr, optional, nullable) {
    return (arg) => {
        if ((0, basic_1.isUndef)(arg)) {
            return !!optional;
        }
        if ((0, basic_1.isNull)(arg)) {
            return !!nullable;
        }
        for (const item of arr) {
            if (arg === item) {
                return true;
            }
        }
        return false;
    };
}
exports.isInRange = _isInRange(false, false, false);
exports.isOptionalInRange = _isInRange(true, false, false);
exports.isNullableInRange = _isInRange(false, true, false);
exports.isNullishInRange = _isInRange(true, true, false);
exports.isInRangeArray = _isInRange(false, false, true);
exports.isOptionalInRangeArray = _isInRange(true, false, true);
exports.isNullableInRangeArray = _isInRange(false, true, true);
exports.isNullishInRangeArray = _isInRange(true, true, true);
function _isInRange(optional, nullable, isArr) {
    return (min, max) => {
        const rangeFn = _initRangeFn(min, max);
        return (arg) => {
            if (arg === undefined) {
                return optional;
            }
            if (arg === null) {
                return nullable;
            }
            if (isArr) {
                return Array.isArray(arg) && !arg.some(item => !_isInRangeHelper(item, rangeFn));
            }
            return _isInRangeHelper(arg, rangeFn);
        };
    };
}
function _isInRangeHelper(arg, rangeFn) {
    if ((0, basic_1.isString)(arg)) {
        if ((0, basic_1.isValidNumber)(arg)) {
            arg = Number(arg);
        }
        else {
            return false;
        }
    }
    if (!(0, basic_1.isNumber)(arg)) {
        return false;
    }
    return rangeFn(arg);
}
function _initRangeFn(min, max) {
    if (Array.isArray(min) && min.length === 1 && Array.isArray(max) && max.length === 1) {
        return ((arg) => arg >= min[0] && arg <= max[0]);
    }
    else if (Array.isArray(min) && min.length === 1 && Array.isArray(max) && max.length === 0) {
        return ((arg) => arg >= min[0]);
    }
    else if (!Array.isArray(min) && Array.isArray(max) && max.length === 0) {
        return ((arg) => arg > min);
    }
    else if (Array.isArray(min) && min.length === 1 && !Array.isArray(max)) {
        return ((arg) => arg >= min[0] && arg < max);
    }
    else if (Array.isArray(min) && min.length === 0 && Array.isArray(max) && max.length === 1) {
        return ((arg) => arg <= max[0]);
    }
    else if (Array.isArray(min) && min.length === 0 && !Array.isArray(max)) {
        return ((arg) => arg < max);
    }
    else if (!Array.isArray(min) && Array.isArray(max) && max.length === 1) {
        return ((arg) => arg > min && arg <= max[0]);
    }
    else if (!Array.isArray(min) && !Array.isArray(max)) {
        return ((arg) => arg > min && arg < max);
    }
    throw new Error('min and max must be number, [number], or []');
}
const isKeyOf = (arg) => _isKeyOf(arg, false, false, false);
exports.isKeyOf = isKeyOf;
const isOptionalKeyOf = (arg) => _isKeyOf(arg, true, false, false);
exports.isOptionalKeyOf = isOptionalKeyOf;
const isNullableKeyOf = (arg) => _isKeyOf(arg, false, true, false);
exports.isNullableKeyOf = isNullableKeyOf;
const isNullishKeyOf = (arg) => _isKeyOf(arg, true, true, false);
exports.isNullishKeyOf = isNullishKeyOf;
const isKeyOfArray = (arg) => _isKeyOf(arg, false, false, true);
exports.isKeyOfArray = isKeyOfArray;
const isOptionalKeyOfArray = (arg) => _isKeyOf(arg, true, false, true);
exports.isOptionalKeyOfArray = isOptionalKeyOfArray;
const isNullableKeyOfArray = (arg) => _isKeyOf(arg, false, true, true);
exports.isNullableKeyOfArray = isNullableKeyOfArray;
const isNullishKeyOfArray = (arg) => _isKeyOf(arg, true, true, true);
exports.isNullishKeyOfArray = isNullishKeyOfArray;
function _isKeyOf(obj, optional, nullable, isArr) {
    if (!(0, basic_1.isObject)(obj)) {
        throw new Error('Item to check from must be a Record<string, unknown>.');
    }
    const isInKeys = (0, exports.isInArray)(Object.keys(obj));
    return (arg) => {
        if (arg === undefined) {
            return optional;
        }
        if (arg === null) {
            return nullable;
        }
        if (isArr) {
            return Array.isArray(arg) && !arg.some(item => !isInKeys(item));
        }
        return isInKeys(arg);
    };
}
exports.isEnum = _isEnum;
exports.isOptionalEnum = (0, common_1.orOptional)(_isEnum);
exports.isNullableEnum = (0, common_1.orNullable)(_isEnum);
exports.isNullishEnum = (0, common_1.orNullable)(exports.isOptionalEnum);
function _isEnum(arg) {
    if (!(0, basic_1.isRecord)(arg)) {
        return false;
    }
    const keys = Object.keys(arg), middle = Math.floor(keys.length / 2);
    if (!(0, basic_1.isNumber)(arg[keys[middle]])) {
        const entries = Object.entries(arg);
        for (const entry of entries) {
            if (!((0, basic_1.isString)(entry[0]) && (0, basic_1.isString)(entry[1]))) {
                return false;
            }
        }
        return true;
    }
    if (keys.length % 2 !== 0) {
        return false;
    }
    for (let i = 0; i < middle; i++) {
        const thisKey = keys[i], thisVal = arg[thisKey], thatKey = keys[i + middle], thatVal = arg[thatKey];
        if (!(thisVal === thatKey && thisKey === String(thatVal))) {
            return false;
        }
    }
    return true;
}
const isEnumVal = (arg) => _isEnumVal(arg, false, false);
exports.isEnumVal = isEnumVal;
const isOptionalEnumVal = (arg) => _isEnumVal(arg, true, false);
exports.isOptionalEnumVal = isOptionalEnumVal;
const isNullableEnumVal = (arg) => _isEnumVal(arg, false, true);
exports.isNullableEnumVal = isNullableEnumVal;
const isNullishEnumVal = (arg) => _isEnumVal(arg, true, true);
exports.isNullishEnumVal = isNullishEnumVal;
function _isEnumVal(enumArg, optional, nullable) {
    if (!(0, exports.isEnum)(enumArg)) {
        throw Error('Item to check from must be an enum.');
    }
    let resp = Object.keys(enumArg).reduce((arr, key) => {
        if (!arr.includes(key)) {
            arr.push(enumArg[key]);
        }
        return arr;
    }, []);
    if ((0, basic_1.isNumber)(enumArg[resp[0]])) {
        resp = resp.map(item => enumArg[item]);
    }
    return (arg) => {
        if ((0, basic_1.isUndef)(arg)) {
            return !!optional;
        }
        if ((0, basic_1.isNull)(arg)) {
            return !!nullable;
        }
        return resp.some(val => arg === val);
    };
}
//# sourceMappingURL=complex-validators.js.map