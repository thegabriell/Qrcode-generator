"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deepCompare = exports.traverseNullishObjectArray = exports.traverseNullableObjectArray = exports.traverseOptionalObjectArray = exports.traverseObjectArray = exports.traverseNullishObject = exports.traverseNullableObject = exports.traverseOptionalObject = exports.traverseObject = exports.testNullishObjectArray = exports.testNullableObjectArray = exports.testOptionalObjectArray = exports.testObjectArray = exports.testNullishObject = exports.testNullableObject = exports.testOptionalObject = exports.testObject = exports.parseNullishObjectArray = exports.parseNullableObjectArray = exports.parseOptionalObjectArray = exports.parseObjectArray = exports.parseNullishObject = exports.parseNullableObject = exports.parseOptionalObject = exports.parseObject = void 0;
exports.nonNullable = nonNullable;
exports.iterateObjectEntries = iterateObjectEntries;
exports.transform = transform;
exports.parseBoolean = parseBoolean;
exports.parseOptionalBoolean = parseOptionalBoolean;
exports.parseNullableBoolean = parseNullableBoolean;
exports.parseNullishBoolean = parseNullishBoolean;
exports.parseJson = parseJson;
exports.parseOptionalJson = parseOptionalJson;
exports.parseNullableJson = parseNullableJson;
exports.parseNullishJson = parseNullishJson;
exports.customDeepCompare = customDeepCompare;
const dist_1 = require("../../dist");
function nonNullable(cb) {
    return (arg) => {
        if ((0, dist_1.isNullOrUndef)(arg)) {
            return false;
        }
        else {
            return cb(arg);
        }
    };
}
function iterateObjectEntries(cb) {
    return (arg) => {
        if ((0, dist_1.isObject)(arg)) {
            for (const entry of Object.entries(arg)) {
                if (!cb(entry[0], entry[1])) {
                    return false;
                }
            }
        }
        return true;
    };
}
function transform(transFn, vldt) {
    return (arg, cb) => {
        if (arg !== undefined) {
            arg = transFn(arg);
        }
        cb?.(arg);
        return vldt(arg);
    };
}
function parseBoolean(arg, errMsg) {
    if (typeof arg === 'string') {
        arg = arg.toLowerCase();
        if (arg === 'true') {
            return true;
        }
        else if (arg === 'false') {
            return false;
        }
        else if (arg === 'yes') {
            return true;
        }
        else if (arg === 'no') {
            return false;
        }
        else if (arg === '1') {
            return true;
        }
        else if (arg === '0') {
            return false;
        }
    }
    else if (typeof arg === 'number') {
        if (arg === 1) {
            return true;
        }
        else if (arg === 0) {
            return false;
        }
    }
    else if (typeof arg === 'boolean') {
        return arg;
    }
    throw new Error(errMsg ?? 'Argument must be a valid boolean.');
}
function parseOptionalBoolean(arg) {
    if (arg === undefined) {
        return arg;
    }
    else {
        return parseBoolean(arg, 'Argument must be a valid boolean | undefined.');
    }
}
function parseNullableBoolean(arg) {
    if (arg === null) {
        return arg;
    }
    else {
        return parseBoolean(arg, 'Argument must be a valid boolean | null.');
    }
}
function parseNullishBoolean(arg) {
    if (arg === null || arg === undefined) {
        return arg;
    }
    else {
        return parseBoolean(arg, 'Argument must be a valid boolean | null | undefined.');
    }
}
function parseJson(arg) {
    if ((0, dist_1.isString)(arg)) {
        return JSON.parse(arg);
    }
    else {
        throw Error('JSON parse argument must be a string.');
    }
}
function parseOptionalJson(arg) {
    if (arg === undefined) {
        return arg;
    }
    else if ((0, dist_1.isString)(arg)) {
        return JSON.parse(arg);
    }
    else {
        throw Error('JSON parse argument must be string or undefined.');
    }
}
function parseNullableJson(arg) {
    if (arg === null) {
        return arg;
    }
    else if ((0, dist_1.isString)(arg)) {
        return JSON.parse(arg);
    }
    else {
        throw Error('JSON parse argument must be string or null.');
    }
}
function parseNullishJson(arg) {
    if (arg === null || arg === undefined) {
        return arg;
    }
    else if ((0, dist_1.isString)(arg)) {
        return JSON.parse(arg);
    }
    else {
        throw Error('JSON parse argument must be string, null, or undefined.');
    }
}
const parseObject = (arg, onError) => _parseObject(arg, false, false, false, onError);
exports.parseObject = parseObject;
const parseOptionalObject = (arg, onError) => _parseObject(arg, true, false, false, onError);
exports.parseOptionalObject = parseOptionalObject;
const parseNullableObject = (arg, onError) => _parseObject(arg, false, true, false, onError);
exports.parseNullableObject = parseNullableObject;
const parseNullishObject = (arg, onError) => _parseObject(arg, true, true, false, onError);
exports.parseNullishObject = parseNullishObject;
const parseObjectArray = (arg, onError) => _parseObject(arg, false, false, true, onError);
exports.parseObjectArray = parseObjectArray;
const parseOptionalObjectArray = (arg, onError) => _parseObject(arg, true, false, true, onError);
exports.parseOptionalObjectArray = parseOptionalObjectArray;
const parseNullableObjectArray = (arg, onError) => _parseObject(arg, false, true, true, onError);
exports.parseNullableObjectArray = parseNullableObjectArray;
const parseNullishObjectArray = (arg, onError) => _parseObject(arg, true, true, true, onError);
exports.parseNullishObjectArray = parseNullishObjectArray;
function _parseObject(schema, optional, nullable, isArr, onError) {
    return (arg) => _parseObjectHelper(!!optional, !!nullable, isArr, schema, arg, onError);
}
function _parseObjectHelper(optional, nullable, isArr, schema, arg, onError) {
    if (arg === undefined) {
        if (!optional) {
            onError?.('Argument is undefined but not optional');
            return undefined;
        }
    }
    if (arg === null) {
        if (!nullable) {
            onError?.('Argument is null but not nullable.');
            return undefined;
        }
        return null;
    }
    if (isArr) {
        if (!Array.isArray(arg)) {
            onError?.('Argument is not an array.', arg);
            return undefined;
        }
        let hasErr = false;
        for (let i = 0; i < arg.length; i++) {
            let cb = undefined;
            if (!!onError) {
                cb = (prop, val, caughtErr) => onError(prop, val, i, caughtErr);
            }
            const parsedItem = _parseObjectHelper2(schema, arg[i], cb);
            if (parsedItem === undefined) {
                if (!!onError) {
                    return undefined;
                }
                else {
                    hasErr = true;
                }
            }
        }
        return (hasErr ? undefined : arg);
    }
    return _parseObjectHelper2(schema, arg, onError);
}
function _parseObjectHelper2(schemaParentObj, argParentObj, onError) {
    if (!(0, dist_1.isRecord)(argParentObj)) {
        return;
    }
    let hasErr = false;
    for (const key in schemaParentObj) {
        const schemaProp = schemaParentObj[key], val = argParentObj[key];
        if ((0, dist_1.isRecord)(schemaProp)) {
            const childVal = _parseObjectHelper2(schemaProp, val, onError);
            if (childVal === undefined) {
                if (!onError) {
                    return undefined;
                }
            }
        }
        else if ((0, dist_1.isFunction)(schemaProp)) {
            try {
                if (!schemaProp(val, (tval) => argParentObj[key] = tval)) {
                    if (!!onError) {
                        hasErr = true;
                        onError(key, val);
                    }
                    else {
                        return undefined;
                    }
                }
            }
            catch (err) {
                if (!!onError) {
                    hasErr = true;
                    if (err instanceof Error) {
                        onError(key, val, err.message);
                    }
                    else {
                        onError(key, val, err);
                    }
                }
                else {
                    return undefined;
                }
            }
        }
    }
    if (hasErr) {
        return undefined;
    }
    for (const key in argParentObj) {
        if (!(key in schemaParentObj)) {
            Reflect.deleteProperty(argParentObj, key);
        }
    }
    return argParentObj;
}
const testObject = (arg, onError) => _testObject(arg, false, false, false, onError);
exports.testObject = testObject;
const testOptionalObject = (arg, onError) => _testObject(arg, true, false, false, onError);
exports.testOptionalObject = testOptionalObject;
const testNullableObject = (arg, onError) => _testObject(arg, false, true, false, onError);
exports.testNullableObject = testNullableObject;
const testNullishObject = (arg, onError) => _testObject(arg, true, true, false, onError);
exports.testNullishObject = testNullishObject;
const testObjectArray = (arg, onError) => _testObject(arg, false, false, true, onError);
exports.testObjectArray = testObjectArray;
const testOptionalObjectArray = (arg, onError) => _testObject(arg, true, false, true, onError);
exports.testOptionalObjectArray = testOptionalObjectArray;
const testNullableObjectArray = (arg, onError) => _testObject(arg, false, true, true, onError);
exports.testNullableObjectArray = testNullableObjectArray;
const testNullishObjectArray = (arg, onError) => _testObject(arg, true, true, true, onError);
exports.testNullishObjectArray = testNullishObjectArray;
function _testObject(schema, optional, nullable, isArr, onError) {
    const parseFn = _parseObject(schema, optional, nullable, isArr, onError);
    return (arg) => {
        const res = parseFn(arg);
        return (res !== undefined);
    };
}
const traverseObject = (cb) => _traverseObject(false, false, false, cb);
exports.traverseObject = traverseObject;
const traverseOptionalObject = (cb) => _traverseObject(true, false, false, cb);
exports.traverseOptionalObject = traverseOptionalObject;
const traverseNullableObject = (cb) => _traverseObject(false, true, false, cb);
exports.traverseNullableObject = traverseNullableObject;
const traverseNullishObject = (cb) => _traverseObject(true, true, false, cb);
exports.traverseNullishObject = traverseNullishObject;
const traverseObjectArray = (cb) => _traverseObject(false, false, true, cb);
exports.traverseObjectArray = traverseObjectArray;
const traverseOptionalObjectArray = (cb) => _traverseObject(true, false, true, cb);
exports.traverseOptionalObjectArray = traverseOptionalObjectArray;
const traverseNullableObjectArray = (cb) => _traverseObject(false, true, true, cb);
exports.traverseNullableObjectArray = traverseNullableObjectArray;
const traverseNullishObjectArray = (cb) => _traverseObject(true, true, true, cb);
exports.traverseNullishObjectArray = traverseNullishObjectArray;
function _traverseObject(optional, nullable, isArray, cb) {
    return (arg) => {
        _traverseObjectHelper(!!optional, !!nullable, isArray, arg, cb);
        return arg;
    };
}
function _traverseObjectHelper(optional, nullable, isArray, arg, cb) {
    if (arg === undefined && !optional) {
        throw new Error('Value was undefined but not optional.');
    }
    if (arg === null && !nullable) {
        throw new Error('Value was null but not nullable.');
    }
    if (isArray) {
        if (!Array.isArray(arg)) {
            throw new Error('Value is not an array.');
        }
        for (const item of arg) {
            _traverseObjectHelperCore(item, cb);
        }
    }
    else {
        _traverseObjectHelperCore(arg, cb);
    }
}
function _traverseObjectHelperCore(parentObj, cb) {
    if (!(0, dist_1.isRecord)(parentObj)) {
        return;
    }
    const entries = Object.entries(parentObj);
    for (const [key, value] of entries) {
        if ((0, dist_1.isRecord)(value)) {
            _traverseObjectHelperCore(value, cb);
        }
        else if (Array.isArray(value)) {
            for (const item of value) {
                _traverseObjectHelperCore(item, cb);
            }
        }
        else {
            cb(key, value, parentObj);
        }
    }
}
exports.deepCompare = customDeepCompare({});
function customDeepCompare(optionsOrCb, cb) {
    let optionsF, cbF = cb;
    if (typeof optionsOrCb === 'object') {
        optionsF = _processOptions(optionsOrCb);
    }
    else if (typeof optionsOrCb === 'function') {
        cbF = optionsOrCb;
        optionsF = { disregardDateException: false };
    }
    return (arg1, arg2) => {
        const opts = { ...optionsF };
        return _customDeepCompareHelper(arg1, arg2, opts, cbF, '');
    };
}
function _processOptions(opts) {
    const retVal = {
        disregardDateException: !!opts.disregardDateException,
    };
    if (!!opts.onlyCompareProps) {
        const ocp = opts.onlyCompareProps;
        if ((0, dist_1.isString)(ocp)) {
            retVal.onlyCompareProps = [ocp];
        }
        else if (Array.isArray(ocp)) {
            retVal.onlyCompareProps = [...ocp];
        }
    }
    if (!!opts.convertToDateProps) {
        const cdp = opts.convertToDateProps;
        if ((0, dist_1.isString)(cdp)) {
            retVal.convertToDateProps = { rec: true, props: [cdp] };
        }
        else if (Array.isArray(cdp)) {
            retVal.convertToDateProps = { rec: true, props: [...cdp] };
        }
        else if ((0, dist_1.isObject)(cdp)) {
            retVal.convertToDateProps = {
                rec: cdp.rec,
                props: Array.isArray(cdp.props) ? [...cdp.props] : [cdp.props],
            };
        }
    }
    return retVal;
}
function _customDeepCompareHelper(arg1, arg2, options, cb, paramKey) {
    if (!(0, dist_1.isObject)(arg1) || arg1 === null || !(0, dist_1.isObject)(arg2) || arg2 === null) {
        const isEqual = (arg1 === arg2);
        if (!isEqual && !!cb) {
            cb(paramKey, arg1, arg2);
        }
        return isEqual;
    }
    if (!options.disregardDateException && ((0, dist_1.isDate)(arg1) && (0, dist_1.isDate)(arg2))) {
        const isEqual = (arg1.getTime() === arg2.getTime());
        if (!isEqual && !!cb) {
            cb(paramKey, arg1, arg2);
        }
        return isEqual;
    }
    if (Array.isArray(arg1) || Array.isArray(arg2)) {
        if (!(Array.isArray(arg1) && Array.isArray(arg2))) {
            cb?.(paramKey, arg1, arg2);
            return false;
        }
        if (!cb && arg1.length !== arg2.length) {
            return false;
        }
        let length = arg1.length, isEqualF = true;
        if (arg2.length > arg1.length) {
            length = arg2.length;
        }
        for (let i = 0; i < length; i++) {
            const isEqual = _customDeepCompareHelper(arg1[i], arg2[i], options, cb, `Index: ${i}`);
            if (!isEqual) {
                if (!cb) {
                    return false;
                }
                isEqualF = false;
            }
        }
        return isEqualF;
    }
    let keys1 = Object.keys(arg1), keys2 = Object.keys(arg2);
    if (!!options?.onlyCompareProps) {
        const props = options.onlyCompareProps;
        keys1 = keys1.filter(key => props.includes(key));
        keys2 = keys2.filter(key => props.includes(key));
    }
    if (!cb && keys1.length !== keys2.length) {
        return false;
    }
    let convertToDateProps;
    if (!!options.convertToDateProps) {
        convertToDateProps = [...options.convertToDateProps.props];
        if (!options.convertToDateProps.rec) {
            delete options.convertToDateProps;
        }
    }
    let keys = keys1;
    if (keys2.length > keys1.length) {
        keys = keys2;
    }
    let isEqual = true;
    for (const key of keys) {
        let val1 = arg1[key], val2 = arg2[key];
        if (arg1.hasOwnProperty(key) && !arg2.hasOwnProperty(key)) {
            if (!!cb) {
                cb(key, val1, 'not present');
                isEqual = false;
                continue;
            }
            else {
                return false;
            }
        }
        else if (!arg1.hasOwnProperty(key) && arg2.hasOwnProperty(key)) {
            if (!!cb) {
                cb(key, 'not present', val2);
                isEqual = false;
                continue;
            }
            else {
                return false;
            }
        }
        if (!!convertToDateProps?.includes(key)) {
            const d1 = new Date(val1), d2 = new Date(val2);
            if (d1.getTime() !== d2.getTime()) {
                if (!!cb) {
                    cb(key, val1, val2);
                    isEqual = false;
                }
                else {
                    return false;
                }
            }
            continue;
        }
        const optionsF = { ...options };
        if (options.onlyCompareProps) {
            delete optionsF.onlyCompareProps;
        }
        if (!_customDeepCompareHelper(val1, val2, optionsF, cb, key)) {
            if (!cb) {
                return false;
            }
            isEqual = false;
            continue;
        }
    }
    return isEqual;
}
//# sourceMappingURL=util-functions.js.map