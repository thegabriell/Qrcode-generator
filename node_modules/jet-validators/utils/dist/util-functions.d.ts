import { TRecord } from '../../dist';
import { TValidateWithTransform } from '../../dist/common';
export declare function nonNullable<T>(cb: ((arg: unknown) => arg is T)): (arg: unknown) => arg is NonNullable<T>;
export declare function iterateObjectEntries<T = NonNullable<object>>(cb: (key: string, val: unknown) => boolean): (arg: unknown) => arg is T;
export declare function transform<T>(transFn: (arg: unknown) => T, vldt: ((arg: unknown) => arg is T)): TValidateWithTransform<T>;
export declare function parseBoolean(arg: unknown, errMsg?: string): boolean;
export declare function parseOptionalBoolean(arg: unknown): boolean | undefined;
export declare function parseNullableBoolean(arg: unknown): boolean | null;
export declare function parseNullishBoolean(arg: unknown): boolean | null | undefined;
export declare function parseJson<T>(arg: unknown): T;
export declare function parseOptionalJson<T>(arg: unknown): T | undefined;
export declare function parseNullableJson<T>(arg: unknown): T | null;
export declare function parseNullishJson<T>(arg: unknown): T | null | undefined;
export interface TSchema {
    [key: string]: TValidateWithTransform<unknown> | TSchema;
}
type TInferParseResHelper<U> = {
    [K in keyof U]: (U[K] extends TValidateWithTransform<infer X> ? X : U[K] extends TSchema ? TInferParseResHelper<U[K]> : never);
};
type TParseOnError<A> = (A extends true ? ((property: string, value?: unknown, index?: number, caughtErr?: unknown) => void) : ((property: string, value?: unknown, caughtErr?: unknown) => void));
export declare const parseObject: <U extends TSchema>(arg: U, onError?: TParseOnError<false>) => (arg: unknown) => TInferParseResHelper<U>;
export declare const parseOptionalObject: <U extends TSchema>(arg: U, onError?: TParseOnError<false>) => (arg: unknown) => TInferParseResHelper<U> | undefined;
export declare const parseNullableObject: <U extends TSchema>(arg: U, onError?: TParseOnError<false>) => (arg: unknown) => TInferParseResHelper<U> | null;
export declare const parseNullishObject: <U extends TSchema>(arg: U, onError?: TParseOnError<false>) => (arg: unknown) => TInferParseResHelper<U> | null | undefined;
export declare const parseObjectArray: <U extends TSchema>(arg: U, onError?: TParseOnError<true>) => (arg: unknown) => TInferParseResHelper<U>[];
export declare const parseOptionalObjectArray: <U extends TSchema>(arg: U, onError?: TParseOnError<true>) => (arg: unknown) => TInferParseResHelper<U>[] | undefined;
export declare const parseNullableObjectArray: <U extends TSchema>(arg: U, onError?: TParseOnError<true>) => (arg: unknown) => TInferParseResHelper<U>[] | null;
export declare const parseNullishObjectArray: <U extends TSchema>(arg: U, onError?: TParseOnError<true>) => (arg: unknown) => TInferParseResHelper<U>[] | null | undefined;
export declare const testObject: <U extends TSchema>(arg: U, onError?: TParseOnError<false>) => (arg: unknown) => arg is TInferParseResHelper<U>;
export declare const testOptionalObject: <U extends TSchema>(arg: U, onError?: TParseOnError<false>) => (arg: unknown) => arg is TInferParseResHelper<U> | undefined;
export declare const testNullableObject: <U extends TSchema>(arg: U, onError?: TParseOnError<false>) => (arg: unknown) => arg is TInferParseResHelper<U> | null;
export declare const testNullishObject: <U extends TSchema>(arg: U, onError?: TParseOnError<false>) => (arg: unknown) => arg is TInferParseResHelper<U> | null | undefined;
export declare const testObjectArray: <U extends TSchema>(arg: U, onError?: TParseOnError<true>) => (arg: unknown) => arg is TInferParseResHelper<U>[];
export declare const testOptionalObjectArray: <U extends TSchema>(arg: U, onError?: TParseOnError<true>) => (arg: unknown) => arg is TInferParseResHelper<U>[] | undefined;
export declare const testNullableObjectArray: <U extends TSchema>(arg: U, onError?: TParseOnError<true>) => (arg: unknown) => arg is TInferParseResHelper<U>[] | null;
export declare const testNullishObjectArray: <U extends TSchema>(arg: U, onError?: TParseOnError<true>) => (arg: unknown) => arg is TInferParseResHelper<U>[] | null | undefined;
type TTraverseCb = (key: string, val: unknown, parentObj: TRecord) => void;
export declare const traverseObject: (cb: TTraverseCb) => <T>(arg: T) => T;
export declare const traverseOptionalObject: (cb: TTraverseCb) => <T>(arg: T) => T;
export declare const traverseNullableObject: (cb: TTraverseCb) => <T>(arg: T) => T;
export declare const traverseNullishObject: (cb: TTraverseCb) => <T>(arg: T) => T;
export declare const traverseObjectArray: (cb: TTraverseCb) => <T>(arg: T) => T;
export declare const traverseOptionalObjectArray: (cb: TTraverseCb) => <T>(arg: T) => T;
export declare const traverseNullableObjectArray: (cb: TTraverseCb) => <T>(arg: T) => T;
export declare const traverseNullishObjectArray: (cb: TTraverseCb) => <T>(arg: T) => T;
type TDeepCompareCb = (key: string, val1: unknown, val2: unknown) => void;
type TDeepCompareFn = (arg1: unknown, arg2: unknown) => boolean;
interface IDeepCompareOptions {
    disregardDateException?: boolean;
    onlyCompareProps?: string | string[];
    convertToDateProps?: string | string[] | {
        rec: boolean;
        props: string | string[];
    };
}
export declare const deepCompare: TDeepCompareFn;
export declare function customDeepCompare(optionsOrCb: IDeepCompareOptions, cb?: TDeepCompareCb): TDeepCompareFn;
export declare function customDeepCompare(optionsOrCb: TDeepCompareCb): TDeepCompareFn;
export {};
