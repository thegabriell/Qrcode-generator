import jetSchema from './jetSchema';
export type { TSchemaFnObjArg as TJetSchema, PublicInferType as inferType, } from './jetSchema';
export { IError, TErrArg } from './error-stuff';
export declare const schema: <T, U extends Required<{ [K in keyof T]: T[K] extends string | number ? import("./util").TEnum | (((arg: unknown) => arg is T[K]) | import("./jetSchema").IValidatorObj<T[K]>) : T[K] extends Date ? DateConstructor | (((arg: unknown) => arg is T[K]) | import("./jetSchema").IValidatorObj<T[K]>) : ((NonNullable<T[K]> extends infer T_1 ? { [K_1 in keyof T_1]: NonNullable<T[K]>[K_1]; } : never) extends (string extends keyof NonNullable<T[K]> ? never : {
    [key: string]: string | number | boolean | (string extends keyof NonNullable<T[K]> ? never : any);
}) ? true : false) extends true ? import("./jetSchema").ISchema<T[K]> : ((arg: unknown) => arg is T[K]) | import("./jetSchema").IValidatorObj<T[K]>; }> = Required<{ [K in keyof T]: T[K] extends string | number ? import("./util").TEnum | (((arg: unknown) => arg is T[K]) | import("./jetSchema").IValidatorObj<T[K]>) : T[K] extends Date ? DateConstructor | (((arg: unknown) => arg is T[K]) | import("./jetSchema").IValidatorObj<T[K]>) : ((NonNullable<T[K]> extends infer T_1 ? { [K_1 in keyof T_1]: NonNullable<T[K]>[K_1]; } : never) extends (string extends keyof NonNullable<T[K]> ? never : {
    [key: string]: string | number | boolean | (string extends keyof NonNullable<T[K]> ? never : any);
}) ? true : false) extends true ? import("./jetSchema").ISchema<T[K]> : ((arg: unknown) => arg is T[K]) | import("./jetSchema").IValidatorObj<T[K]>; }>, R extends unknown extends T ? import("./jetSchema").IOptNul | import("./jetSchema").IOptNotNul | import("./jetSchema").INotOptButNul | import("./jetSchema").INotOptOrNul | import("./jetSchema").INullish : undefined extends T ? null extends T ? import("./jetSchema").IOptNul | import("./jetSchema").INullish : import("./jetSchema").IOptNotNul : null extends T ? import("./jetSchema").INotOptButNul : import("./jetSchema").INotOptOrNul = unknown extends T ? import("./jetSchema").IOptNul | import("./jetSchema").IOptNotNul | import("./jetSchema").INotOptButNul | import("./jetSchema").INotOptOrNul | import("./jetSchema").INullish : undefined extends T ? null extends T ? import("./jetSchema").IOptNul | import("./jetSchema").INullish : import("./jetSchema").IOptNotNul : null extends T ? import("./jetSchema").INotOptButNul : import("./jetSchema").INotOptOrNul>(schemaFnObjArg: U, ...options: unknown extends T ? [] | [R] : undefined extends T ? [R] : null extends T ? [R] : [] | [R]) => unknown extends T ? import("./jetSchema").ISchema<"nullish" extends keyof R ? NonNullable<Exclude<{ [K_3 in keyof { [K_2 in keyof U]: U[K_2] extends DateConstructor ? Date : U[K_2] extends ((arg: unknown) => arg is infer X) | import("./jetSchema").IValidatorObj<infer X> ? X : U[K_2] extends import("./jetSchema").ISchema<infer X_1> ? X_1 : U[K_2] extends unknown[] ? never : U[K_2] extends import("./util").TEnum ? U[K_2][keyof U[K_2]] : never; }]-?: (x: undefined extends { [K_2 in keyof U]: U[K_2] extends DateConstructor ? Date : U[K_2] extends ((arg: unknown) => arg is infer X) | import("./jetSchema").IValidatorObj<infer X> ? X : U[K_2] extends import("./jetSchema").ISchema<infer X_1> ? X_1 : U[K_2] extends unknown[] ? never : U[K_2] extends import("./util").TEnum ? U[K_2][keyof U[K_2]] : never; }[K_3] ? Partial<Record<K_3, { [K_2 in keyof U]: U[K_2] extends DateConstructor ? Date : U[K_2] extends ((arg: unknown) => arg is infer X) | import("./jetSchema").IValidatorObj<infer X> ? X : U[K_2] extends import("./jetSchema").ISchema<infer X_1> ? X_1 : U[K_2] extends unknown[] ? never : U[K_2] extends import("./util").TEnum ? U[K_2][keyof U[K_2]] : never; }[K_3]>> : Record<K_3, { [K_2 in keyof U]: U[K_2] extends DateConstructor ? Date : U[K_2] extends ((arg: unknown) => arg is infer X) | import("./jetSchema").IValidatorObj<infer X> ? X : U[K_2] extends import("./jetSchema").ISchema<infer X_1> ? X_1 : U[K_2] extends unknown[] ? never : U[K_2] extends import("./util").TEnum ? U[K_2][keyof U[K_2]] : never; }[K_3]>) => void; }[keyof U] extends (x: infer I) => void ? I extends infer U_1 ? { [K_4 in keyof U_1]: U_1[K_4]; } : never : never, undefined>> | null | undefined : ("optional" extends keyof R ? R[keyof R & "optional"] : false) extends infer T_2 ? T_2 extends ("optional" extends keyof R ? R[keyof R & "optional"] : false) ? T_2 extends true ? (("nullable" extends keyof R ? R[keyof R & "nullable"] : false) extends infer T_3 ? T_3 extends ("nullable" extends keyof R ? R[keyof R & "nullable"] : false) ? T_3 extends true ? NonNullable<Exclude<{ [K_3 in keyof { [K_2 in keyof U]: U[K_2] extends DateConstructor ? Date : U[K_2] extends ((arg: unknown) => arg is infer X) | import("./jetSchema").IValidatorObj<infer X> ? X : U[K_2] extends import("./jetSchema").ISchema<infer X_1> ? X_1 : U[K_2] extends unknown[] ? never : U[K_2] extends import("./util").TEnum ? U[K_2][keyof U[K_2]] : never; }]-?: (x: undefined extends { [K_2 in keyof U]: U[K_2] extends DateConstructor ? Date : U[K_2] extends ((arg: unknown) => arg is infer X) | import("./jetSchema").IValidatorObj<infer X> ? X : U[K_2] extends import("./jetSchema").ISchema<infer X_1> ? X_1 : U[K_2] extends unknown[] ? never : U[K_2] extends import("./util").TEnum ? U[K_2][keyof U[K_2]] : never; }[K_3] ? Partial<Record<K_3, { [K_2 in keyof U]: U[K_2] extends DateConstructor ? Date : U[K_2] extends ((arg: unknown) => arg is infer X) | import("./jetSchema").IValidatorObj<infer X> ? X : U[K_2] extends import("./jetSchema").ISchema<infer X_1> ? X_1 : U[K_2] extends unknown[] ? never : U[K_2] extends import("./util").TEnum ? U[K_2][keyof U[K_2]] : never; }[K_3]>> : Record<K_3, { [K_2 in keyof U]: U[K_2] extends DateConstructor ? Date : U[K_2] extends ((arg: unknown) => arg is infer X) | import("./jetSchema").IValidatorObj<infer X> ? X : U[K_2] extends import("./jetSchema").ISchema<infer X_1> ? X_1 : U[K_2] extends unknown[] ? never : U[K_2] extends import("./util").TEnum ? U[K_2][keyof U[K_2]] : never; }[K_3]>) => void; }[keyof U] extends (x: infer I) => void ? I extends infer U_1 ? { [K_4 in keyof U_1]: U_1[K_4]; } : never : never, undefined>> | null : NonNullable<Exclude<{ [K_3 in keyof { [K_2 in keyof U]: U[K_2] extends DateConstructor ? Date : U[K_2] extends ((arg: unknown) => arg is infer X) | import("./jetSchema").IValidatorObj<infer X> ? X : U[K_2] extends import("./jetSchema").ISchema<infer X_1> ? X_1 : U[K_2] extends unknown[] ? never : U[K_2] extends import("./util").TEnum ? U[K_2][keyof U[K_2]] : never; }]-?: (x: undefined extends { [K_2 in keyof U]: U[K_2] extends DateConstructor ? Date : U[K_2] extends ((arg: unknown) => arg is infer X) | import("./jetSchema").IValidatorObj<infer X> ? X : U[K_2] extends import("./jetSchema").ISchema<infer X_1> ? X_1 : U[K_2] extends unknown[] ? never : U[K_2] extends import("./util").TEnum ? U[K_2][keyof U[K_2]] : never; }[K_3] ? Partial<Record<K_3, { [K_2 in keyof U]: U[K_2] extends DateConstructor ? Date : U[K_2] extends ((arg: unknown) => arg is infer X) | import("./jetSchema").IValidatorObj<infer X> ? X : U[K_2] extends import("./jetSchema").ISchema<infer X_1> ? X_1 : U[K_2] extends unknown[] ? never : U[K_2] extends import("./util").TEnum ? U[K_2][keyof U[K_2]] : never; }[K_3]>> : Record<K_3, { [K_2 in keyof U]: U[K_2] extends DateConstructor ? Date : U[K_2] extends ((arg: unknown) => arg is infer X) | import("./jetSchema").IValidatorObj<infer X> ? X : U[K_2] extends import("./jetSchema").ISchema<infer X_1> ? X_1 : U[K_2] extends unknown[] ? never : U[K_2] extends import("./util").TEnum ? U[K_2][keyof U[K_2]] : never; }[K_3]>) => void; }[keyof U] extends (x: infer I) => void ? I extends infer U_1 ? { [K_4 in keyof U_1]: U_1[K_4]; } : never : never, undefined>> : never : never) | undefined : ("nullable" extends keyof R ? R[keyof R & "nullable"] : false) extends infer T_3 ? T_3 extends ("nullable" extends keyof R ? R[keyof R & "nullable"] : false) ? T_3 extends true ? NonNullable<Exclude<{ [K_3 in keyof { [K_2 in keyof U]: U[K_2] extends DateConstructor ? Date : U[K_2] extends ((arg: unknown) => arg is infer X) | import("./jetSchema").IValidatorObj<infer X> ? X : U[K_2] extends import("./jetSchema").ISchema<infer X_1> ? X_1 : U[K_2] extends unknown[] ? never : U[K_2] extends import("./util").TEnum ? U[K_2][keyof U[K_2]] : never; }]-?: (x: undefined extends { [K_2 in keyof U]: U[K_2] extends DateConstructor ? Date : U[K_2] extends ((arg: unknown) => arg is infer X) | import("./jetSchema").IValidatorObj<infer X> ? X : U[K_2] extends import("./jetSchema").ISchema<infer X_1> ? X_1 : U[K_2] extends unknown[] ? never : U[K_2] extends import("./util").TEnum ? U[K_2][keyof U[K_2]] : never; }[K_3] ? Partial<Record<K_3, { [K_2 in keyof U]: U[K_2] extends DateConstructor ? Date : U[K_2] extends ((arg: unknown) => arg is infer X) | import("./jetSchema").IValidatorObj<infer X> ? X : U[K_2] extends import("./jetSchema").ISchema<infer X_1> ? X_1 : U[K_2] extends unknown[] ? never : U[K_2] extends import("./util").TEnum ? U[K_2][keyof U[K_2]] : never; }[K_3]>> : Record<K_3, { [K_2 in keyof U]: U[K_2] extends DateConstructor ? Date : U[K_2] extends ((arg: unknown) => arg is infer X) | import("./jetSchema").IValidatorObj<infer X> ? X : U[K_2] extends import("./jetSchema").ISchema<infer X_1> ? X_1 : U[K_2] extends unknown[] ? never : U[K_2] extends import("./util").TEnum ? U[K_2][keyof U[K_2]] : never; }[K_3]>) => void; }[keyof U] extends (x: infer I) => void ? I extends infer U_1 ? { [K_4 in keyof U_1]: U_1[K_4]; } : never : never, undefined>> | null : NonNullable<Exclude<{ [K_3 in keyof { [K_2 in keyof U]: U[K_2] extends DateConstructor ? Date : U[K_2] extends ((arg: unknown) => arg is infer X) | import("./jetSchema").IValidatorObj<infer X> ? X : U[K_2] extends import("./jetSchema").ISchema<infer X_1> ? X_1 : U[K_2] extends unknown[] ? never : U[K_2] extends import("./util").TEnum ? U[K_2][keyof U[K_2]] : never; }]-?: (x: undefined extends { [K_2 in keyof U]: U[K_2] extends DateConstructor ? Date : U[K_2] extends ((arg: unknown) => arg is infer X) | import("./jetSchema").IValidatorObj<infer X> ? X : U[K_2] extends import("./jetSchema").ISchema<infer X_1> ? X_1 : U[K_2] extends unknown[] ? never : U[K_2] extends import("./util").TEnum ? U[K_2][keyof U[K_2]] : never; }[K_3] ? Partial<Record<K_3, { [K_2 in keyof U]: U[K_2] extends DateConstructor ? Date : U[K_2] extends ((arg: unknown) => arg is infer X) | import("./jetSchema").IValidatorObj<infer X> ? X : U[K_2] extends import("./jetSchema").ISchema<infer X_1> ? X_1 : U[K_2] extends unknown[] ? never : U[K_2] extends import("./util").TEnum ? U[K_2][keyof U[K_2]] : never; }[K_3]>> : Record<K_3, { [K_2 in keyof U]: U[K_2] extends DateConstructor ? Date : U[K_2] extends ((arg: unknown) => arg is infer X) | import("./jetSchema").IValidatorObj<infer X> ? X : U[K_2] extends import("./jetSchema").ISchema<infer X_1> ? X_1 : U[K_2] extends unknown[] ? never : U[K_2] extends import("./util").TEnum ? U[K_2][keyof U[K_2]] : never; }[K_3]>) => void; }[keyof U] extends (x: infer I) => void ? I extends infer U_1 ? { [K_4 in keyof U_1]: U_1[K_4]; } : never : never, undefined>> : never : never : never : never> : import("./jetSchema").ISchema<T>;
export default jetSchema;
