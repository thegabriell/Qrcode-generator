export declare const Errors: {
    readonly Init: "\"init:\" option must be \"true\" if schema is not optional.";
    readonly DefaultVal: "Default value did not pass validation.";
    readonly Validator: string;
    readonly PropValidation: "Validator function failed.";
    readonly UndefButNotOpt: "Argument was undefined but not optional.";
    readonly NullButNotNullable: "Argument was null but not nullable";
    readonly NotAnObj: "Argument must be an object.";
    readonly StrictMode: "Extra properties not allowed in strict mode.";
};
export type TErrArg = string | IError | (string | IError)[];
export type TOnError = (errors: TErrArg) => void;
export type TFormatError = (error: IError) => IError | string;
export interface IError {
    property?: string;
    value?: unknown;
    message?: string;
    location?: string;
    schemaId?: string;
}
export declare function defaultOnError(errors?: TErrArg): void;
export declare function getErrObj(message?: string, location?: string, schemaId?: string, property?: string, value?: unknown): IError;
